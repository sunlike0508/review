# DP의 아름다움

## 품질 좋은 코드란?

품질 좋은 코드란 무엇인가?

가독성? 남들이 읽기 좋은 코드? 그거에 대한 기준은 무엇인가?

재사용이 높다고 해서 가독성이 좋은가? 그건 아니다. ex) 과거 자바의 stack 클래스. 많은 사람들에게 이용되었지만 결국에 사장됌.

가장 좋은 재사용이 높은 메소드는 당연히 매개변수가 없는 것. 아니면 단 하나.

내가 하려는 알고리즘을 묶어서 어휘를 붙여주자.

가독성이란 언어의 구조물을 이용해서 어휘를 붙여나가는 작업에 가깝다.

켄트백 : 프로그래밍이란 자기만의 어휘를 만들어가는 과정

팀의 약속을 통해 가독성을 위한 수많은 가정을 지워나가는 것. 그래서 사실상 팀과의 약속을 해나가는 과정이라 본다.

## 코드리뷰

코드리뷰? 무조건 좋은가? 당연히 좋다. 근데 회사 입장에서는? 코드리뷰 또한 리소스의 소모이다.

코드리뷰는 보통 2가시 형식, 투표제, 마스터제. 투표제를 하면 정치싸움으로 변질되기 쉽다.(책임회피) 마스터제는 마스터가 개고생한다. 그러다 결국 포기.

지금 뭐 우리 회사, 우리 팀 코드리뷰 좋아요 한다고 하지만 장기적으로 1,2년 지나다보면 퇴색이 된다. 그럼 코드리뷰 어떻게 해야하는가?

그냥 돈을 쓰자. 인원을 더 뽑든가, 돈을 더 주든가. (구글이 코드리뷰 하는 이유)

그렇다고 뭐 돈 투자하는게 짱이다? 그런 뉘앙스는 아니고, 서로 참여자들의 고민과 토론을 해보자. 물론 이것도 리소스 소모이지만...

## 객체지향 프로그래밍

캡슐화, 추상화, 상속, 다형성

이것들은 객체지향 프로그래밍의 4대 요소라고 불리는데... 도대체 어디서 나오는 주장인가? 일단 아니다.

### 캡슐화

데이터은닉 : 접근 제어

캡슐화 : 제한된 메소드 노출, 속성을 캡슐화

* 목적

사용자의 학습 비용 감소

사용시 오류 확률 감소

사용자에게 노출할 비즈니스의 범위를 결정할 수 있다.

사용자가 학습할 인터페이스를 구성할 수 있다.

여기서 말하는 범위는 누가, 무슨 기준으로 정할 것인가?

개발자가 이걸 정하나? 클라이언트가 하나?

예를 들어 물류시스템을 만든다고 할때 내가(개발자) 단지 send만 만들고 나중에 하나씩 클라이언트가 필요할때마다 캡슐화를 풀건가?


### 상속

상속이 연쇄된 의존성을 만들어냄. 그래서 상위로 갈수록 수정이 어려워짐

그러나 상속 단계에서 구현을 재활용할 수 있다.

내적동질성의 런타임 유지에 큰 비용이 듬. (오버라이딩을 따라가니 (즉, 포인터를 따라가서) 메모리 사용이 높아짐)

하위 층이 상위 층에 의존하기 쉬움. 물론 항상 그런건 아니다. 

abstract 클래스에 private 변수와 public 메소드만 사용하고 모든 abstract 메소드를 protected로 선언하면 하위 클래스는 상위 클래스에 의존하지 않음.

이게 템플릿 메소드. 부모 클래스에 의존하지 않기 때문에 권장.


```java
abstract class Parent {
  private String name; 

  public void print() {
    System.out.println(name);
  }

  protected abstract void introduce();
}
```

name은 pirvate이기 때문에 Parent를 상속받는 클래스는 접근 할수 없기 때문에 의존성 없음.

print 함수는 public(공개)이기 때문에 딱히 자식만 의존만 하는것은 아님

introduce는 protected는 abstract이기 때문에 의존성이 없다.


#### 인터페이스

1단게 의존성만 만들어냄. (연쇄X)

모든 의존하는 타입에 구현을 만들어야 함. (깊이 있게 구현하는 abstract을 대체하여 옆으로 얕고 길게)

* 트레이트

인터페이스와 흡사, 타입과 인터페이스의 연결을 별도로 정의함.

타입에 인터페이스를 추가하기 쉬움.

**추상클래스나 인터페이스나 당연하지만 장단점이 있으므로 잘 생각해서 선택**

#### 타입 계층

사용하는 입장(호스트 코드)에서는 추상화된 연산(부모클래스의 abstract 메소드)에 의존하게 됨

추상화된 연산의 변경이 매우 힘듬 : 인터페이스의 A라는 메소드에 인자를 하나 추가할때 그 아래 퍼지는 영향이 매우 크다.

추상층에 의존하는 모든 구상층의 연산을 변경해야 함 : 위랑 같은 얘기

데이터가 많고 연산이 정해진 경우 유효함 : 

이를 타입 계층이라고 부름 : 

여기서 타입은 연산의 집함임

타입 계층을 도입하는 것은 신중해야한다. 연산이 거의 없는 경우 도입

#### 추상 데이터 타입

제공되는 타입은 1개이나 내부에 다양한 데이터를 소유할 수 있음

각 연산 내부에서 데이터를 분기하여 처리함

데이터의 종류가 늘어날때 마다 모든 연산을 고쳐야함

반대로 연산을 늘리기는 쉬움


타입계층과 추상데이터 타입의 중간은 아직 없다... 잘 비즈니스 보고 해보자.

상속의 깊이는 어디까지 짜야할까? 엔터프라이즈의 사이즈를 생각해보자. 현재보다 커질 가능성이 커지거나 혹은 원래 크거나 혹은 참여자가 많은 경우 상속의 깊이는 얇고 단순하게 만들면 좋다.

변종의 자식들이 나올 가능성이 적어지기 때문에. 

물론 정말로 추상화를 잘하면...?


### 다형성

(계층적) 대체가능성 : 구상형은 추상형을 대체 가능

내적동질성 : 생성형이 언제나 연산을 실행함

```java
class Parent {
  void print() {
    System.out.println("panent");
  }
}

class Child extend Parent {
  @Overrride
  void print() {
    System.out.println("panent");
  }
}

Parent whoAmI = new Child();
whoAmI.print();
```

(그냥 자바 규칙 다 생각하지 않고 순수하게 봤을때) 누군가는 whoAmI가 print를 찍었을때 parent라고 나오는게 맞는거 아냐라고 생각할수 있잖아.

근데 결과는 whoAmI 는 앞에 선언한 인터페이스가 변경되어도 나는 처음부터 태어난게 child이기 때문에 print를 호출하면 반드시 child가 출력된다.

이러한 성질을 내적동질성이라고 한다.

언어학자들이 그냥 대체가능성, 내적동질성. 이 두 개를 반드시 포함해야 객체지향 언어라고 부르기로 정함.


### 추상화

추상화를 넘는지만이 설계, 디자인을 할수가 없다. 즉, 코드의 계층을 이해할 없다. 당연히 DDD도 못한다.

추상화를 몰라도 구현의 품질은 올라갈수 있다만...

책에서는

1.메서드 내부 구현을 숨김

2.메서드가 제공하는 기능에만 집중

3.구현 정보를 분리해 인지적 복잡성을 낮춤.

위의 3개를 위한 방법은 ? 추상적인 이름짓기

그럼 추상적인 이름짓기는 어떻게 해?

* 추상화 레벨 결정
1. 구체화된 이름 제거
2. 보다 본질적인 목적으로 변경

ex) get Naver Cloud Picture Url

이런 이름을 가진 메소드가 있다고 해보자.

Naver.Cloud.Url(url).get(picture) 라는 뜻으로 만들었을 것이다. 이건 추상화 된건가?

***추상화는 본질적으로 이름을 잘짓기 이딴게 아니다***

무엇을 어떻게 추상화 레벨을 결정하는건가?

누군 잘하고 누군 못하고 도대체 차이가 뭘까?

**추상화기법(인지이론)

1. Modeling 필요한 부분만 추출 : 그럼 대체 무엇이 필요한건가?

2. Categorizing : 특정 기준으로 동일하게 취급. 분류한다. 동일하게 취급한다. 즉, 단순화 시킨다.

3. Grouping : 임의의 집단으로 묶어서 관리

**추상화기법(생각의 탄생)

1. 관찰 : 생각의 한 형태로 감각적 경험과 지적의식을 가깝게 연결하여 감각작용을 이해하는 것

2. 형상화 : 관찰의 결과를 시각적인 형태로 그려내는 것

3. 추상화 : 세부적인 내용을 이해하고 이를 제거하여 오직 전체를 대표할 수 있는 하나만 남기는 것

4. 패턴인식 : 추상화를 통해 단순화 된 것들 사이의 규칙을 찾아내고 더 나아가 여러 패턴들 사이를 연결하는 메타패턴을 찾아내는 것

5. 패턴형성 : 인식했던 패턴들을 다른 대상에게도 발견하여 적용하는 것 뿐 아니라 패턴의 조합으로 문제를 해결하는 것

**추상화기법(추상대수학)

1. 방적식 등 수를 사용하는 행위 관찰로 수체계를 재정의

2. 군체환 : 특정 설징과 연산이 통용되는 것으로 특정 수를 정희할 수 있고 더 나아가 다양한 수들을 통합하여 이해하고 다룰 수 있게 됨.

3. 위상수학과의 연결 : 군론이 위상공간마다 대응할 수 있음을 알게 되고 위상공간마다의 군을 통합하여 인식할 수 있게 됨. 이를 범주라고 함.

4. 범주 간에도 관계나 대응을 찾아 낼수 있게 되어 펑터가 등장함.

**추상화기법(컴퓨터언어론)

1. 제어추상화 : 반복, 순차처리, 조건, 동시성 (명령)
2. 데이터추상화 : type, variable (메모리)

제어와 상태를 추상화하여 사용

컴퓨터는 명령과 메모리를 나뉘어져서 저장되어 이루어져있다.

조용호님의 객체지향의 사실과 오해라는 책에 나오는 이야기.

**추상화기법(소프트웨어공학)

1. 일반화와 특수화
2. 집합과 분해
3. 분류와 인스턴스화

is member of : 연관화(association) : 이거는 ~의 멤버야

is instance of : 분류화(classification) : 이거는 ~의 인스턴스화야.

is part of : 집단화(aggregation) : 이거는 ~의 소속이야.

is a : 일반화(generalization) : 이거는 이거야. 상속받았을 때 일어나는 일


도대체 무엇을 추상화할 것인가? 어떻게 잘 할것인가? 고민해봐라.

훈련? 그것도 아님. 열심히 공부하고 노력해도 안되는 사람도 있음. 

그럼 답은 될놈될? 될놈될은 이미 비싼 기업에...

추상화에 도달하지 못한 사람의 코드를 보면 코드가 그지 같다. 

예를 들면 수학의 정석을 외운다고 수능을 잘보냐?

유지보수를 하다보면 추상화의 정도(?)를 알 수 있기도함. 

A를 고쳤는데 B에서 사고가? 분리가 안되어 있고 의존성이 높음.






















# 1회차

## 컴퓨터 프로그램의 구조와 명령어 처리 과정

<img width="777" alt="화면 캡처 2024-10-05 011729" src="https://github.com/user-attachments/assets/d7fa5f55-d2c6-4d7a-aabe-b2cf69ecdc3c">

프로그램이 뭔지 이해해야 한다.

프로그램은 코드가 아니다.

코드는 프로그램, 즉, 단지 물리적인 저장소에 있는 파일일뿐이지 프로그램이 아니다.

파일을 실행해서 OS가 메모리에 적재한 상태가 프로그램이다.

위에 그림에서 명령을 통해 값이 메모리에 올라간 상태 그것이 프로그램이다.

컴퓨터는 순차적으로 명령을 실행하는데 중간에 분기처리하거나 명령에서 다시 점프명령을 통해 특정 부위로 이동한다.

기본적으로 명령이 다 끝나면 프로그램은 종료된다.

명령이 실행되기 위해서 cpu쪽으로 올라온다. cpu에서 명령을 실행한다. 이때 보통 값을 메모리에 올려놓고 실행한다. 

올라온 메모리를 명령에 맞게 연산을 하고 그것을 다시 메모리에 적재한다.

명령을 전문적인 용어로 instruction 이라하고 이걸 cpu로 가져오는걸 fetch라고 한다.

한마디로 명령을 계속해서 소비해가며 값을 연산하여 메모리에 적재하는 것이 프로그램이다. (폰 노이만 구조)

## 컴파일과 스크립트 언어의 로딩 차이

<img width="701" alt="image" src="https://github.com/user-attachments/assets/d1fc9e0f-4412-429e-a594-30d42e13d7bd">

컴파일을 하면 프로그램이 실행되기 위한 가장 기초적인 함수 정의를 로딩해주는 과정을 (essential definition loading)이라 한다.

우리가 작성한 변수명을 실제 메모리에 확보하면서 물리적인 메모리 주소랑 매핑 되는 V테이블 매핑(Vtable mapping)이란 과정이 있고 그 다음 실행(Run)된다.

그러면 기초 정의들을 로딩하고 옷과 변수 공간을 이용해서 실행을 하다가 런타임중에도 위에 과정을 할 수 있다. (Runtime definition loading)

자바는 이렇게 런타임에 동적로딩을 할 수 있었기에 성공했다.

30개의 함수가 있다면 처음에는 10개만 올렸다가 나중에 20개 올리는게 효율적이다. 어떤 경우는 15개만 필요한데 처음부터 30개 다 올리면 메모리가 비효율적이다.

<img width="631" alt="image" src="https://github.com/user-attachments/assets/824d0b9a-af68-4aee-adf3-d844244bdb1d">

스크립트는 반면에 다르다. 기본적인 함수를 로딩하고 실행하고 다음 실행에서 다시 기본적인 함수를 로딩하고 사용하는 작업을 반복한다.

왜냐하면 컴파일 과정이 없기 때문이다.

## 프로그래밍 기초 및 코드 구조 이해

<img width="617" alt="image" src="https://github.com/user-attachments/assets/d4a633a6-990d-4f1b-ad6b-e06a5cbb3453">

문맥 자유 문법 BNF 파서에 따르 우리는 토큰이라는 기준으로 코드를 작성한다.

그럼 토큰이 뭐냐? 바로 위에 그림이다.

공백문자는 우리가 아는 공백이다. 공백은 스페이스만이 아닌 공백문자가 60개 이상이 있다.(물론 대부분 우리가 직접 사용 못한다)

개행문자(줄바꿈) 또한 6가지의 종류가 있다.

리터럴이라는 것은 그 언어가 인정하고 있는 값에 대한 표현 중에 더 이상 쪼갤 수 없는 최소한의 표현이다.

자바만 봐도 L을 붙이거나 D를 붙여 LONG형 DOUBLE형을 붙여서 더 이상 쪼갤수 없는 숫자라는 값의 표현이다.

Boolean 또한 true, false 외에 다른 표현을 할 수가 없다.

## 리터럴의 중요성

리터럴을 강조하는 이유는 언어에서 어떤 값을 표현하기 위한 수단으로 리터럴을 계속해서 수정해 가기 때문이다.

예를 들어, 자바스트립트 경우 숫자 사이에 _를 넣을 수 있다. 10 을 써도 혹은 10_0 써도 같은 10이다.

또 1_2_3_4 해도 1 2 3 4 숫자인다. 여러가지 리터럴이 추가되어 같은 숫자를 여러가지 표현을 할 수 있다.

## 언어들의 발전과 특징, 메모리와 변수

<img width="667" alt="image" src="https://github.com/user-attachments/assets/38270640-427e-4afb-8a5f-e26fbfb95c50">

대부분의 언어는 ABC언어이다. A언어가 나오고 B언어가 나오고 단점을 다 개선해서 C언어가 나왔다.

문, 식, 식별자로 이루어져있다.

문은 컴파일러가 해석한 뒤 명령으로 바꿔주는 애들이다.

식은 컴파일러가 해석하고 값으로 바꿔준 애들이다.

식별자란 식은 값을 해석하지만 식의 위치를 알아야 한다. 그 위치에 대한 별명이 식별자다.

EX) 우리가 변수 IN A =3 라는 것을 선언했으면 A는 특정 메모리 주소에 별명이라는 것이다. 3이 식이다. INT는 명령어.

변수랑 메모리의 주소고 식별자 또한 메모리를 식별하기 위한 기호이다.

## 컴퓨터 프로그램 작성의 패턴과 중요성

컴퓨터가 잘하는건 반복이다.

근데 우리는 반복을 잘하는 코드를 짜는게 아니라 애매하게 코드르 짠다.

현실세계의 패턴을 찾아 반복하는 코드를 짜야한다.

패턴을 발견한다는 것은 머리가 좋다는 얘기다.

다르게 말하면 패턴을 못 찾는 것은 머리가 나쁘다.

다행히도... 머리가 나빠도 훈련을 통해 머리를 좋게 만들 수 있다.

다 이해하고 많은 공부를 해도 코드를 못짠다. 그것은 패턴을 못 찾았기 때문에.

현실 세계를 패턴으로 파악하자. 이것을 추론이라 한다.

## 플로우 컨트롤과 블록 컨트롤 & 서브 루틴

<img width="701" alt="image" src="https://github.com/user-attachments/assets/25ec7b26-265b-477e-bb15-0bcc00350a1a">

ABC언어는 수학적으로 극히 제한적인 명령어로 모든걸 제어할 수 있다는 것을 증명했다.

그래서 극히 제한된 점프만 사용 가능하다. 그 전에 사용된 점프(루프)가 흔적이 남아있던게 label, breank, continue 같은 것이다.

<img width="682" alt="image" src="https://github.com/user-attachments/assets/4514d7ba-655f-4efb-bbe1-7dd1c091670d">

여러번 반복해서 쓸수 있는 플로우를 서브 플로우라고 한다. 플로우란 말은 명령에서만 쓰이고 보통 코드적으 루틴이라고 부른다.

<img width="506" alt="image" src="https://github.com/user-attachments/assets/0220c70d-22fa-4e18-b457-49a98d76b9f3">

여기서 우리가 알 수 있는 것은 서브 플로우가 끝나고 다시 돌아 올 수 있는 복귀 위치(포인트)를 안다는 것이다.

## 루틴과 함수 호출 과정에서 메모리 스택 현상 설명

<img width="686" alt="image" src="https://github.com/user-attachments/assets/b052166b-e1fd-4c3f-b6da-51d8c718da0e">

루틴 A는 루틴 B가 돌아올때까지 기다려야한다. 즉, 메모리를 계속 잡고 있다.

이것을 스택 구조라고 한다. 스택의 특징은 메모리 구조중에서 가장 속도가 빠른다. 끝에 넣은거 끝에꺼 부터 빼니까 어디 지점을 기억할 필요가 없다.

## 덧셈과 for문

```java
int accumulator = 0

for(int i = 1; i <= 10; i++) {
  accumulator += i;
}
return accumulator;
```

1부터 10까지 더하라고 하면 우리는 저렇게 일단 떠오른다. 왜일까?

1. 불안감. 무슨 말이냐면 한눈에 파악하려는 의도, 즉, 내가 다 제어해야 안심할 꺼라는 생각.

while recursive, for는 iterator 상황(더 정확히 계약된)에서 쓰인다. 그 뉘앙스를, 차이점을 알아야 한다. 

우리는 같다고 생각하겠지만, 엄연히 다르다. 우리가 한국어를 자연스럽게 안녕, 안녕하세요 쓰지만 한국어를 모르는 사람에게는 같은 인사일뿐이다.

하지만 우리는 이것을 상황과 장소게 맞게 다르게 쓰인다.

for는 우리가 for를 쓰기전 반복 조건을 확정짓고 쓰는 경우이다.

`for(int i = 0; i <= 10; i++)`을 보면 i는 10번까지 반복하겠다라고 확정짓고 쓰는 것이다.

즉, 확실히 반복을 얼마나 할지 알때 쓰는거다. while은 반복을 얼마나 할지 모를 때 사용.

우리는 우리 눈으로 어떻게 돌아가는지 보고 싶어서 저렇게 작성한다.

2. 나의 컨트롤을 벗어나서 짤 자신이 없기 때문에

accumulator를 보면 for 밖에서 정의되어서 밖에서 사용된다. 내가 알고 싶은건 accumulator 인데 accumulator를 for로 보내서 결과를 하나씩 

다 보고 싶기 때문에. 우리는 고작해봐야 for문으로 제어할 수 있는 것은 구구단이다.

순수한 for문으로 json파서를 짤 수 있는가? 실력을 가늠할 수 있는...

다시 돌아가면...

1부터 10까지 더하는 과정은

* (1~9의 합) + 10
* ((1~8의 합) + 9) + 10
* (((1~7의 합) + 8) + 9) + 10

이런 반복, 즉 패턴을 발견할 수 있다. 이걸 찾자.. 훈련하자...

### 최적화 되지 않은 재귀함수

```java
int accumulatorV1(int i) {
  return i > 1 ? i + accumulatorV1(i - 1) : 1;
}
```

삼항식을 왜 읽기 어렵다고 할까 혹은 왜 하지 말라고 하는걸까?

그걸 보는 사람이 멍청하기 때문.... 컨벤션은 못하는 사람을 위해 맞춰져 있기 때문에. 팀에 다같이 참여하니까 못하는 사람에 맞춰져 있음.

언어는 머리 좋은 사람이 만들었는데 머리 나쁜 사람에 맞춰서 컨벤션을 맞춘다? 이것도 웃김.

가독성이 좋다라고 하는 것은 정확힌 기준이 있어야 한다. 

정당한 사유가 없이 내 마음에 안든다고 다 레거시가 절대 아니다.

컴퓨터가 에러없이 잘 소화하면 다 맞는 코드이다.

단지 유지보수 측면에서 어떤 코드가 더 유리하거나 불리하다 차이일뿐.

## 프로그램 개발과 창조성에 관한 통찰

프로그램을 잘때 전지적인 관점에서 모든걸 통제하지 말자.

국지적인 관점으로 반복적인 패턴을 발견해서 문제를 해결하자.

그럼 그 다음문제는? 그건 다음 단계에 떠넘기라. 문제를 해결 자세를 수동적인 자세로 바라보자.

sum(10)은 sum(9)와 다르다. sum(10)이 하는건 10 + sum(9)만 하겠다는 거지 sum(9)가 할일에 관심이 없다.

## 메모리 관련 컴퓨터 작동 이슈, 해결법

자 근데 위에 재귀함수를 100000번 돌려보자. 그럼 보통 죽는다. 왜 ? 컴파일러나 자바스크립트 엔진이 코드를 돌리다가 죽인다.

자바 같은건 현재 남아있는 스택을 다 사용할떄까지 사용한다. 그러다 죽인다. (컴퓨터의 현재 상황, 스펙, 언어마다 케바케)

그러나 안드로이드 같은건 제한적인 스택을 걸어둔다. os의 메모리를 중요시하기 때문에.

***함수를 호출하고 갔다 와서 할일이 있다면 그 할일을 함수 안에 인자로 바꿔주는게 핵심이다.***

### 꼬리 물기 재귀함수

```java
private static int accumulatorV2(int v, int acc) {
    return v > 1 ? accumulatorV2(v - 1, acc + v) : acc + 1;
}

// 실행 : accumulatorV2(10);
```

이거를 다시 for문으로 바꿔보자

```java
int v = 10; // accumulatorV2(10)
int acc = 0;

for (int i = acc; i > 1 ; i--) { // v > 1, v - 1
    acc += i; // acc + i
}

acc += 1; // acc + 1
```

자, 패턴이 보이는가? 반복문은 기계적으로 for문으로 바꿀 수 있다.

***결론적으로 일단 패턴을 찾아. 그리고 최적화 되지 않은 재귀함수 작성. 그리고 최적화된 재귀함수 작성 마지막으로 기계적으로 for 작성***

우리는 보았다 이 고성능의 컴퓨터를 가지고 10만번도 반복해서 못 더 한다. 따라서 우리는 이거를 무조건 FOR문으로 바꿔야 한다.

그럼 처음부터 for로 만들면 되잖아? 위에는 코드가 짧으니까 쉬우니까. 근데 더 어렵고 복잡한 상황이라면? 우리는 이걸 바로 for짤수없다.

따라서 처음부터 재귀로 생각해서 해야한다.

처음 말한 json 파서를 생각해보자. 처음부터 for으로 풀수 있겠는가? 그런 실력이 우린 없다. 그런 사람이 있다? 그건 천재...

## 과제

1차원 배열의 합 재귀, 꼬리 재귀, FOR 문

## 변수의 속성. life cycle과 scope

int v = 10

v는 뭘까? 이건 상수라고 한다. 상수는 뭘까? 특정 컨텍스트하(해결하려는 문제)에서 미리 주어진 값

내가 이거를 문제를 해결하기 위해 사용되는 값이기 때문에 대부분의 언어에서는 이것을 변경할 수 없는 값으로 설정한다.

int acc = 0;

acc는 뭘까? 이건 저장소. 데이터를 보관하는 변수

i는 뭘까? 이거는 제어변수라고 한다. 제어 변수는 여러가지 종류가 있는데 여기서는 counter라고 부른다.

변수가 다 변수가 아니다. 변수의 목적을 정확히 이해하고 사용해야 한다. 즉, 변수의 역할을 우리가 알고 써야 한다.

변수를 잘 모르니 코드를 못 짜는 것이다.

### 스코프 

스코프란 어휘공간(일반적인 권한). 어떤 책에서는 권한이라고도 한다. 권한은 또 예외적인 스코프라고도 할 수 있다.

일반적인 권한은 뭔데? 중괄호, 함수를 말한다.

그러면 예외적인 권한이란 중괄호, 함수를 벗어난 공간을 말한다. (자바에서는 멤버변수를 말함)

그럼 라이플 사이클은? 변수가 얼마나 생존하느냐. 

스코프랑 같아 보이는데? 아니 다르다.

예를 들어 참조변수 같은 것은 라이프 사이클랑 스코프랑 범위가 다를 수 있다.

일단 우리는 라이프 사이클, 스코프 모두 짧게 유지하도록 해야한다.

왜? 우리가 멍청해서 기억할 수 없기 떄문에. 컴퓨터는 기억한다. 그러나 사람을 믿을 수 없다. 누군가 수정하기 때문에. 누가? 1주일뒤에 내가.

사람은 보통 7줄이상 넘어가면 기억하기 힘들다. 그래서 함수를 7줄 이하 이내로 짜라는 이유다. 이건 학자들이 실험한 결과이다.

다시 돌아가면 재귀로 짜면 3줄이면 끝난다. 그리고 저장소 변수도 없다.

그러나 for로 짜면 6줄로 늘어나고 저장소 변수도 생겨난다. 위에는 간단한 예제로 차이가 없어보이지만 조금 더 복잡하다면

우리는 for문을 이해할 수도 없고 한번에 짤수가 없다.

# DP의 아름다움2

## Prodecure Oriented 프로시져 지향

절차적 지향? 아니다 번역이 잘못됌.

프로시져 -> 상태와 상태를 변화시키는 명령을 분리하여 생각함.

상태란 명령 흐름에 따라 계속 변화하고 최종 결론에 도달.

상태를 변경하는 흐름에 나눠서 문제를 분할함.

**노이만머신 프로그래밍 그 자체. 프로시저란 이거를 추상화 시킨 것**

그래서 분기나 반복 등 복잡한 흐름이 집합 수준에서 생기면 통제가 어려워짐.

상태는 결과적, 로그가 없음. 디버깅시 별도로깅. 시간 흐름이 중요.

결국 시간이 정말로 중요. 시간의 흐름에 따라서 결과가 정해짐.

질문 ? 근데 객체지향이라는 것도 상태라는 것을 가지고 있고 이것도 결국 시간의 흐름에 따라서 결과가 바뀌는데 무슨 차이가 있는가?

상태변화는 결과적이지만, 상태가 격리되어 상태를 컨트롤할수 있는게 딱 하나의 객체로만 정해져 있다. 즉, 책임소재가 확실하기 때문에 프로시져 지향보다 대규모 프로젝트에 적합하다.
(단, 정보은닉, 캡슐화가 잘되어 있다는 가정. 당연히도 이게 깨짐 객체 지향이라고 할 수가 없다.)


## setter를 통한 DI 대응은 어디까지 용서해야 하는가?

1. 애노테이션 프로세서 등 컴타임 타임 플러그인 의존만 허용.
2. 지연 할당을 위한 런타임 DI 대응을 위해 코딩 규약을 쓰자.

## Convert 함수

엔티티를 레포로 가져와서 비즈니스 옵젝으로 변경하는것? 도대체 무엇임?

1. walletBO = walletEntity.convert(); = 컨버터는 엔티티꺼야
  * 레포가 도메인에 맞춰 끼워 넣어줌
  * 도메인을 레포에 의존하지 않고 애플리케이션에서 주도
  * 그럼 누가 변하고 누가 안변하는건가?
  * 엔티티는 변하는데 BO는 변하지 않는다. 왜?
  * 애플리케이션에서 중심의 도메인은 모두 BO가 가지있어 튼튼하고 엔티티는 물리계층에 있기 때문에 효율적으로 계속해서 바꿀수 있다.
  * 유지보수 입장에서는 BO가 애플리케이션에서 더 많이 활약할수록 엔티티의 역할은 하찮기 때문에 유지보수가 쉽다.
2. walletBO = new WalletBO().convert(walletEntity); = 컨버터는 비즈니스 옵젝이야
  * 도메인이 레포를 해석함
  * ERD등이 도메인 중심인 경우 고래해볼만함
4. walletBO = walletService.convert(walletEntity); = 컨버터는 서비스꺼야.
  * 프로젝트가 보다 대규모라 레포와 도메인 양쪽을 중계하는게 더 효율적인 경우는 고려해볼만 함.

즉, 컨버터를 가지고 있는쪽이 오히려 변화에 대응하기 쉽다. 컨버터를 당하는 쪽이 딱딱하고 유지보수가 어렵다.

질문 : 컨버터는 그냥 타입을 변경해주는 간단한 작업이라고 생각하는데 무슨 차이임? 

답: 맴버 row ID기준을 하는 테이블을 가지고 가정. ERD 중심으로 광범위한 로그인이라고 생각해보자. 맴버테이블 유효ID만 발급하고 이 유효 ID를 물고 있는

페이스북 로그인테이블, 이메일 로그인테이블, 아이디패스워드 로그인테이블 나눠서 ERD로 내렸다고 가정하자. 

그러면 엔티티의 내용이 완전히 달라짐. 이걸 수용한 맴버BO를 만들어야함.

거꾸로 도메인 중심. 맴버테이블이 정규화되어 5개로 되었든, 아니면 하나로만 이루어졌든 우리는 맴버 BO 하나만 만들면 돼. 

BO가 확고할수록 엔티티 레이어는 변화를 할 수가 없음. 그리고 도메인에 관여할 수 없음. 점점 데이터 저장소로 변함.

정규화할수록 엔티티와 레포의 변경이 도메인에 점점 관여. 엔티티의 변화가 비즈니스 전체의 변화를 일으킴

맹기완님 개인적 의견 : 나는 풍부한 도메인을 별로 좋아하지 않음. -> 시간이 흐를수록 사람도 바뀌고 요구사항도 바뀌기 때문에 유지보수 측면에서 잘 안되기 때문에. 그래서 그냥 ERD 모델로 하는게 나을수도 있다.


## 서비스의 책임

프로시져 지향에서는 서비스가 객체의 상태를 책임졌다면 객체지향에서는 객체가 자신의 상태를 책임진다.

어디까지 서비스가 중계해야 하는가? 고민해보자....

1. 간이 DI로 동작하고 객체 간 협력은 각 객체에서 구현. 미디에이터, 진입점, 컨테이너 수준
2. 변환, 메시지 중계, 중간 상태 관리, 트랜잭션 중계등 협력 구현 퍼사드, 프로시져 지향
3. 협력은 각 객체가 구현하고 의존성은 DI컨테이너가 처리. 서비스는 진입점 역할 및 로깅 등 별도의 관심사만 처리하기 위해 존재

위와 같은 역할들이 있을 수도 있다.

풍성한 도메인 모델은 해당 모델에서 도메인 지식과 처리 단계를 소유하므로 역할을 축소키킴.


## 풍성한 도메인 모델과 RDB

1. SQL(쿼리)는 곧 ERD의 결과임, 따라서 빈약한 도메인 모델은 정규화된 ERD 구조에 의존하는 서비스라 간접적으로 시사함.
2. 풍성한 도메인은 주요 로직이 애플리케이션에 탑재되므로 이론상 저장소는 어떤 구조로 가져도 상관없고 도메인 모델을 잘 저장할수만 있으면 됨

**풍성한 도메인 모델을 쓰면서 정교하게 모델링 된 ERD와의 관계를 어떻게 설정할 것인가?**

에시) ENUM을 ERD로 넣을것인가

엔티티는 객체가 아니다. 그냥 구조일뿐. 그래서 은식할 필요도 없음. 그냥 순수 데이터. 

근데 BO는 반대. 객체. 정보은닉해야함. 그래서 애를 밖에서 내장을 까려고 하면 안됌. 그래서 위에 2번 BO가 엔티티를 받아서 convert하는게 나은 경우가 많다.

## 추상클래스와 인터페이스

1. 추상클래스는 (구현타입과) 격리된 상태를 추가로 사용함.
   * private을 제외한 속성이나 메소드에 의존하면 프로시져 지향. 왜냐하면 자식이 부모클래스의 속성이나 메소드를 건드릴수 있으니까
   * 상속이 나쁜게 아닌데 상속이 나쁜 이유는 super키워드와 pivate이 아닌 속성을 가능하게 해주는 가시성이다. -> 이거 두개 모두 불가능한게 인터페이스
   * 상태를 사용하지 않는 추상층의 메소드는 보통 유틸 함수임 -> this가 필요하면 메소드 this가 필요없으면 static 유틸 메소드
   * 따라서 템플릿 패턴을 추천
   * 격리 상태 기반의 메소드는 결국 별도 전략객체로 분리가능 -> 추상클래스의 private 메소드는 결국 별도의 객체로 나온다. 굳이 추상클래스를 부모로 둘 필요는 없다.
   * 그래서 추상클래스가 존재해야하는 이유는 타입계층을 만들어서 강제허거나, 템플릿 메소드 패턴 쓸때만 쓴다
   * 결국 타입 계층을 이용할 것이냐 말것이냐 가장 중요한 문제
  
2. 추상클래스는 계층이 무한히 깊어질 수 있음.
   * 계층이 깊어지면 각 층을 이해해야 함 (프레임워크를 공부하기 어려운 이유...)
   * 새 기능 추가 시 적합한 계층을 판정해야 함.

3. 인터페이스는 깊어지지 않고 넓어짐
   * 구상클래스를 기능 단위로 분해해서 사용함(SPR 위반위험) -> 한 클래스가 여러 인터페이스(하나의 책임을 가지고 있음) implement를 하면 SRP 위반 아님?
   * 구현은 조합이 가능하지만 사용 시 조합 문제

```text
interface A{};
interface B{}:
interface C{}:

class ABC{}; // 개념적으로 A,B, C를 가진 하나의 클래스

fun <T> get() T where T:A, T:B
fun <T> set(v:T) where T:A, T:C
```
내가 리턴하은 값이 싶은 A이면서 B야 혹은 내가 받고 싶은 인자가 A이면서 C야. 어떡함?
그래서 

class AB: A, B
class AC: A, C

이렇게 늘어남. 실제 intersaction type을 지원하지 않으면 결국 인터페이스 조합만큼의 구상타입을 만들어야 함. 현실적으로 인터페이스 기반으로 기능 분리하기가 어려움.

그래서 실제 상속을 지양하고 합성과 위임을 권장함.

## 상향식 하향식

1. 추상클래스가 상향식일까?
   * 구상 클래스의 교집합을 묶을 때 인터페이스로 묶을 수도 있음
   * 구현시 상태가 개입하는 경우도 외부 전략객체를 가져오면 됨
   * 상태를 추상층과 구상층이 공유하면 프로시져 지향 프로그래밍
  
2. 그렇다면 추상클래스(타입계층구조)의 의미와 가치는?
   * 왜 계층을 두는가?
   * 인지적인 카테고리를 제공함 ex) Number 아래, integer, long을 두는 것. Integer, Long에 interface로 계산한다는 기능만 제공해도 되는데 추상클래스로 Number를 두는 건?
   * 인터페이스는 어떤 타입도 구상할 수 있는데 비해 추상클래스의 기능은 오직 해당 타입계층에게만 제공되게 제약됨.
   * 즉, 인터페이스는 누구나 가져다 쓸수 있다. 하지만 추상은 내가 허락한 자식만 나의 기능을 가져다 쓸수있다.
   * 타입계층은 결국 내가 허락한 클래스에게만 나의 기능을 허락한다.
   * 물론 요즘 인터페이스에도 default를 지원하긴 하지만
   * 결국 기능의 묶음은 인터페이스나 추상클래스 동일하게 제공할 수 있지만 사용할 수 있는 타입을 제약할 것인가 아닌가에 달려있음
  
***기능이 일반화될 수 있는 것인가, 아니면 특정 타입계층에서만 의미있는가***

물론 둘다 있을 수 있다.

맹님 주장 : 예를 들어 tosring, hashcode 이런거는 사실 어느 곳이든 사용가능하기 때문에 인터페이스로 나오는게 맞다고 생각한다. 왜 일반적이니까. 

자바진영에서는 모든 객체에 object를 상속받게 구현되어 있어서 tostring 기능을 강제 제공하고 싶기에 지금 그렇게 되어 있지만.

옆으로 커지든 아래로 깊어지든 컨텍스트를 하나만 가지고 있느냐가 중요. (단일 책임의 원칙)

단일 책임의 원칙을 지키면 커지든 내려가든 컨텍스트를 하나만 가지고 있다면 조합폭발이 일어나지 않는다.

예를 들어 운송이라는 컨텍스트를 유지하면, 사람운송, 자동차 운송, 오토바이운송 이렇게 가로로 퍼질수 있고 또 사람운송도 도보운송, 자전거 운송 이렇게 아래로 내려간다.

근데 여기서 옆에 결제 이런게 붙으면 이제 조합폭발이 일어남

타입의 개수가 많은건 그만큼 도메인이 많다는 것. if가 곧 도메인 . 남자냐 여자냐 나눠야 하니까 남자도 도메인, 여자도 도메인.

타입이 많은건 당연한거. 도메인이 그렇게 많은거니까. 단지 타입 계층 카테고리를 만들때 컨텍스트를 여러개 가지고 있는 계층을 만들지 않도록 노력해야한다.

운송 패키지에 갑자기 주유급유라는 컨텍스트를 슬며시 넣음. 운송이니까 주유급유가 왠지 들어가야 할것 같은데? 아니다라는 것.

## 위임객체와 본객체의 가시성

1. 위임객체와 본객체의 내부 가시성을 전혀 접근할 수 없는 경우
   * 본객체의 인터페이스로 위임객체를 지정할 이유가 없음
   * 본객체의 인터페이스 구현이 위임객체와 본객체의 상태를 섞어서 구현하는 경우 굳이 위임객체가 해당 인터페이스가 될 이유가 없음.
     (어차피 개별 구상 클래스마다 따로 구현해야 하니까)     

2. 위임객체가 본 객체의 public 미만의 가시성에 접근가능한 경우
   * 위임 객체를 위해 본객체가 public으로 승격하면 캡슐화 붕괴
   * 내부클래스 등 언어 특수 기능을 쓰게 되는 경우 특정 쿠상클래스에 바인딩되어 일반화된 위임객체를 얻을 수 없음. 

```kotlin
interface A {
  fun a()
}
class Test:A {
   private val delegate = ConcreateA()

   override fun a() = delegate.a()
}

// 1번째 상황


class Test:A {
   private val delegate = ConcreateA()
   private var b;
   private fun c(){}

   override fun a() {
      b = delegate.a()
      c()
   }
}

// 2번재 상황
```
위의 상황이 생기면 왜 위임객체를 만듦?

뭔가 본능적으로 합성, 위임 패턴 안쓸꺼야. 딱 봐도 이상하잖아.

***위임객체가 성립하려면 위임객체와 본객체 간에 추가적인 교환 인터페이스가 정의되어야 함. 단 이 경우에도 이러한 교환 인터페이스가 공개되는 단점***

결국 위임객체가 의미가 있으려면 본객체랑 통신해야함. 근데 내장을 까지 않으려면 결국 서로 통신하기 위한 중간 인터페이스(or 추상클래스)가 필요함

```java
interface Next<T> {
    <T> int next(T t);
}

class ItemIncreaseNext<T> implements Next<T> {

    private Item<T> item;
    private int cursor = 0;

    ItemIncreaseNext(Item<T> item) {
        this.item = item;
    }

    @Override
    public <T> int next(T t) {
        return item.get(cursor);
    }
}

abstract class Item<T> {
    abstract <T> int get(int key);
}

class IntItem extends Item<Integer> implements Next<Item<Integer>> {

    private ItemIncreaseNext<Integer> delegator = new ItemIncreaseNext<>(this);

    @Override
    <T> int get(int key) {
        return 3;
    }


    @Override
    public <T> int next(T t) {
        return delegator.next(t);
    }
}
```

``` java
abstract class Item<T> {
    abstract <T> int get(int key);
}

interface Item<T> {
  <T> int get(int key);
}
```
위에는 아래처럼 변경 가능하나 오픈되어지기 때문에 위험

